<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="description" content="A course about C++"><meta name="author" content="SofiaCPP"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="stylesheet" href="/advanced-cpp/bower_components/reveal.js/css/reveal.min.css"/><link rel="stylesheet" href="/advanced-cpp/css/advanced_cxx.css"><link rel="stylesheet" href="/advanced-cpp/css/tomorrow.css"><title>Virtual functions in C++</title></head><body><div class="reveal"><div class="slides"><section><h1>Inheritance and virtual functions</h1>
</section><section><h2>Contents</h2>
<ul>
<li>Object layout</li>
<li>Inheritance</li>
<li>Multiple inheritance</li>
<li>Virtual functions</li>
<li>Virtual inheritance</li>
</ul>
</section><section><section><h1>Object Layout</h1>
</section><section><pre><code>class Pawn {
    int m_Id;
    bool m_IsAlive;
    int m_HP;
}
</code></pre>
</section><section><p>The members of the class are laid out in the same order in memory as they are declared.</p>
</section><section><p>Dumping the layout of a struct.</p>
<pre><code>clang++ -cc1 -fdump-record-layouts file.cxx
</code></pre>
<p>http://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang</p>
</section><section><pre><code>0 | struct Pawn
0 |   int m_Id
4 |   _Bool m_IsAlive
8 |   int m_HP
  | [sizeof=12, dsize=12, align=4
  |  nvsize=12, nvalign=4]
</code></pre>
</section><section><ul>
<li>The digit in the first column is the offset of the member in the stuct.</li>
<li>sizeof is how much the <code>sizeof</code> operator will return</li>
<li>dsize is the size without the extra tail padding</li>
<li>align is the alignment of the structure</li>
</ul>
</section><section><h3>Alignment</h3>
<p>https://en.wikipedia.org/wiki/Data_structure_alignment</p>
</section><section><p>In short - the CPU is most effective to load data at addresses that are multiple
of a 4, 8, 16, 64, etc. Therefore the compiler generates the code so that the
address of every variable is a multiple of its alignment.</p>
</section><section><p>In C++11, the <code>alignof</code> operator gives the alignment of a type.</p>
<pre><code>static_assert(alignof(bool) == 1, &quot;the alignment of bool is 1&quot;);
</code></pre>
</section><section><ul>
<li><code>m_IsAlive</code> is <code>bool</code>, size 1, alignment 1</li>
<li><code>m_HP</code> is <code>int</code> - size 4, alignment 4</li>
</ul>
<p>The compiler must create a hole of 3 bytes in <code>Pawn</code> in order to fulfill the
alignment of <code>m_HP</code>.</p>
</section><section><h3>Padding</h3>
<p>The extra empty spaces that the compiler places inside user-defined types in
order to properly align their members.</p>
</section><section><h3>Padding caveats</h3>
<p>The padding is filled with random data. You <em>SHOULD</em> never use it.</p>
<pre><code>Pawn p1, p2;

if (std::memcmp(&amp;p1, &amp;p2, sizeof(p1)))
</code></pre>
<p>This will take the 3 random bytes in <code>p1</code> and <code>p2</code> into the comparison and might
return that they are different, although all of their data members are actually
equal.</p>
</section><p>+++</p>
</section><section><section><h2>Inheritance</h2>
</section><section><pre><code>struct Player : Pawn {
    const char* m_Name;
    int m_Score;
};
</code></pre>
</section><section><p>The alignment of pointers depends on the architecture. So the layout also
depends on the architecture.</p>
</section><section><p>64-bit architecture</p>
<pre><code> 0 | struct Player
 0 |   struct Pawn (base)
 0 |     int m_Id
 4 |     _Bool m_IsAlive
 8 |     int m_HP
16 |   const char * m_Name
24 |   int m_Score
   | [sizeof=32, dsize=28, align=8
   |  nvsize=28, nvalign=8]
</code></pre>
</section><section><p>32-bit architecture</p>
<pre><code> 0 | struct Player
 0 |   struct Pawn (base)
 0 |     int m_Id
 4 |     _Bool m_IsAlive
 8 |     int m_HP
12 |   const char * m_Name
16 |   int m_Score
   | [sizeof=20, dsize=20, align=4
   |  nvsize=20, nvalign=4]
</code></pre>
</section><section><h2>Multiple inheritance</h2>
</section><section><pre><code>struct Enemy {
    int m_Damage;
};

struct EnemyPawn : Pawn, Enemy {
    int m_TargetId;
};
</code></pre>
</section><section><pre><code>0 | struct Enemy
0 |   int m_Damage
  | [sizeof=4, dsize=4, align=4
  |  nvsize=4, nvalign=4]
</code></pre>
</section><section><pre><code> 0 | struct EnemyPawn
 0 |   struct Pawn (base)
 0 |     int m_Id
 4 |     _Bool m_IsAlive
 8 |     int m_HP
12 |   struct Enemy (base)
12 |     int m_Damage
16 |   int m_TargetId
   | [sizeof=20, dsize=20, align=4
   |  nvsize=20, nvalign=4]
</code></pre>
</section><section><p>The members of the derived class are laid out after the members of the base
class.</p>
</section></section><section><section><h1>Virtual Functions</h1>
</section><section><pre><code>struct Pawn {
    virtual ~Pawn() {} 
    virtual void NotOverridden() {}
    virtual int Move() { return 0; }
    int m_Id;
    bool m_IsAlive;
    int m_HP;
};
</code></pre>
</section><section><pre><code>struct Player : Pawn {
    virtual ~Player() {}
    virtual int Move() override { return 42; }
    const char* m_Name;
    int m_Score;
};
</code></pre>
</section><section><p>Virtual functions in C++ are implemented with the so called <em>virtual table</em>. The
<em>virtual table</em> is an array of pointers to methods. Whenever a virtual method is
called, the code lookups the pointer to the method in the <em>virtual table</em> and
executes it.</p>
</section><section><pre><code>Pawn* p = new Player;

p-&gt;Move();
// actually it is:
(p-&gt;*(p-&gt;vtable[index_for_Move]))();
</code></pre>
</section><section><pre><code>Vtable for Pawn
Pawn::vtable for Pawn: 6u entries
0     (int (*)(...))0
8     (int (*)(...))(&amp; typeinfo for Pawn)
16    (int (*)(...))Pawn::~Pawn
24    (int (*)(...))Pawn::~Pawn
32    (int (*)(...))Pawn::NotOverridden
40    (int (*)(...))Pawn::Move
</code></pre>
</section><section><pre><code>Player::vtable for Player: 6u entries
0     (int (*)(...))0
8     (int (*)(...))(&amp; typeinfo for Player)
16    (int (*)(...))Player::~Player
24    (int (*)(...))Player::~Player
32    (int (*)(...))Pawn::NotOverridden
40    (int (*)(...))Player::Move
</code></pre>
</section><section><h3>Layout</h3>
</section><section><pre><code> 0 | struct Pawn
 0 |   (Pawn vtable pointer)
 8 |   int m_Id
12 |   _Bool m_IsAlive
16 |   int m_HP
   | [sizeof=24, dsize=20, align=8
   |  nvsize=20, nvalign=8]
</code></pre>
</section><section><pre><code> 0 | struct Player
 0 |   struct Pawn (primary base)
 0 |     (Pawn vtable pointer)
 8 |     int m_Id
12 |     _Bool m_IsAlive
16 |     int m_HP
24 |   const char * m_Name
32 |   int m_Score
   | [sizeof=40, dsize=36, align=8
   |  nvsize=36, nvalign=8]
</code></pre>
</section><section><p><code>clang++</code>'s <code>-fdump-vtable-laouts</code> did not output anything.</p>
<p>The virtual tables are dumped with:</p>
<pre><code>g++ -fdump-class-hierarchy -std=c++11 -c vlayout.cc 
</code></pre>
</section><section><h3>Multiple-inheritance</h3>
<pre><code>class FlyingPawn : public Pawn, public Flying
{
    int m_FlyingPawnMember;
};
</code></pre>
</section><section><p>The same as single inheritance, all the base classes are at the beginning of the
object in the order their are inherited.</p>
</section><section><p>Given:</p>
<pre><code>class Flying {
    public:
        int altitude;
};
</code></pre>
</section><section><h4>Pointer assignment</h4>
<pre><code>FlyingPawn fp;
Flying* f = &amp;fp;
cout &lt;&lt; f-&gt;altitude &lt;&lt; std::endl;
// compiler generates cout &lt;&lt; reinterpret_cast_cast&lt;int*&gt;(f) &lt;&lt; endl;
</code></pre>
<p>What is requried from <code>Flying* f = &amp;fp;</code> in order for the code to work?</p>
</section><section><pre><code>FlyingPawn fp;
Flying* f = &amp;fp;
// compiler generates f = &amp;fp + offset_of_Flying_in_FlyingPawn
</code></pre>
<p>The offset is known at compile time, so there is no significant runtime penalty.</p>
</section><section><pre><code>Flying* f = new FlyingPawn;
delete f;
</code></pre>
</section><section><p>Undefined behaviour. Best case - warning for deleting an object with virtual
method and without virtual destructor.</p>
</section><section><h3>Virtual inheritance</h3>
<p>The idea is simple - instead of having the base class at a fixed at compile
time offset, use a runtime offset.</p>
<p>Runtime offset - actually a pointer to the base class.</p>
</section><section><pre><code>struct Player : virtual Pawn {
    const char* m_Name;
    int m_Score;
};
</code></pre>
</section><section><p>The compiler generates a pointer to <code>Pawn</code> at the beginning of <code>Player</code> and
places the actual <code>Pawn</code> instance somewhere in <code>Player</code>.</p>
<p><em>Somewhere</em> is at the end for most implementations.</p>
</section><section><h3>Multiple-inheritance with virtual functions</h3>
<p>The object gets multiple virtual tables, one for each base class with virtual
functions. Each virtual table has the same indices as the virtual table of the
corresponding base class.</p>
</section><section><h2>Setting of the vtable pointer</h2>
</section><section><p><strong>Pseudo-C++ class for virtual tables</strong></p>
<pre><code>class VTable;
</code></pre>
</section><section><pre><code>struct Pawn {
    Pawn(int health)
        : _vtbl(VTable_Pawn) // added by the compiler
        , m_Health(healt)
    {}
    virtual ~Pawn()
        : _vtbl(VTable_Pawn) // added by the compiler
    {}
    VTable* _vtbl;
    int m_Health;
};
</code></pre>
</section><section><pre><code>struct Player : Pawn {
    Player(int health, int score)
        : Pawn(health)
        , _vtbl(VTable_Player)
        , m_Score(score)
    {}
    virtual ~Player()
        : _vtbl(VTable_Pawn) // added by the compiler
    {
        this-&gt;~Pawn(); // added by the compiler
    }
    VTable* _vtbl;
    int m_Score;
};
</code></pre>
</section><section><h1>virtual functions are not virtual inside constructors and destructors</h1>
</section><section><p>Otherwise the virtual function will execute over not-yet constructed or already
destroyed object.</p>
</section><section><h1><code>C++11</code> <code>final</code> classes</h1>
<p>Cannot be derived from.</p>
<ul>
<li>show intention</li>
<li>optimizations - de-virtualization</li>
</ul>
</section></section></div></div><script src="/advanced-cpp/bower_components/reveal.js/lib/js/head.min.js"></script><script src="/advanced-cpp/bower_components/reveal.js/js/reveal.min.js"></script><script src="/advanced-cpp/bower_components/reveal.js/plugin/highlight/highlight.js"></script><script src="/advanced-cpp/bower_components/jquery/dist/jquery.min.js"></script><script src="/advanced-cpp/slides.js"></script></body></html>